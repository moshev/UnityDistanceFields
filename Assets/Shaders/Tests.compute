#pragma kernel RaymarchMain
#pragma kernel DistanceMain
#define _DIST_FUNCTION _dist_xform_1
float _dist_xform_1(float3 p);
#include "RaymarchUtils.cginc"
#include "RaymarchMainCompute.cginc"
StructuredBuffer<raycontext> _input;
RWStructuredBuffer<rayresult> _output;
[numthreads(32, 1, 1)]
void RaymarchMain(uint3 dispatchId : SV_DispatchThreadID)
{
    uint arrId = dispatchId.x;
    rayresult res;
    res = trace(_input[arrId]);
    _output[arrId] = res;
}
[numthreads(32, 1, 1)]
void DistanceMain(uint3 dispatchId : SV_DispatchThreadID)
{
    uint arrId = dispatchId.x;
    rayresult res;
    res.p = float3(0, 0, 0);
    res.n = normalize(grad(_input[arrId].p));
    res.distance = _DIST_FUNCTION(_input[arrId].p);
    _output[arrId] = res;
}
float3 _translation_1;
float4 _rotation_1;

int _Iterations_1;
float _Cx_1;
float _Cy_1;
float _Cz_1;
float _Cw_1;

float _dist_1(float3 p) {
    float4 c = float4(_Cx_1, _Cy_1, _Cz_1, _Cw_1);
    float4 z = float4(p,0.0);
    float md2 = 1.0;
    float mz2 = dot(z,z);

    for( int i=0; i<_Iterations_1; i++ )
    {
        // |dz|^2 -> 4*|dz|^2
        md2 *= 4.0*mz2;
        
        // z -> z2 + c
        z = float4( z.x*z.x-dot(z.yzw,z.yzw), 2.0*z.x*z.yzw ) + c;

        mz2 = dot(z,z);
        if(mz2>4.0) break;
    }
    
    return 0.25*sqrt(mz2/md2)*log(mz2);
}

float _dist_xform_1(float3 p) {
    return _dist_1(qrot(qinv(_rotation_1), p - _translation_1));
}

