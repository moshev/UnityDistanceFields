#pragma kernel RaymarchMain
#pragma kernel DistanceMain
#define _DIST_FUNCTION _dist_xform_3
float _dist_xform_3(float3 p);
#include "RaymarchUtils.cginc"
#include "RaymarchMainCompute.cginc"
StructuredBuffer<raycontext> _input;
RWStructuredBuffer<rayresult> _output;
[numthreads(128, 1, 1)]
void RaymarchMain(uint3 dispatchId : SV_DispatchThreadID)
{
    uint arrId = dispatchId.x;
    rayresult res;
    res = trace(_input[arrId]);
    _output[arrId] = res;
}
[numthreads(128, 1, 1)]
void DistanceMain(uint3 dispatchId : SV_DispatchThreadID)
{
    uint arrId = dispatchId.x;
    rayresult res;
    res.p = float3(0, 0, 0);
    res.n = normalize(grad(_input[arrId].p));
    res.distance = _DIST_FUNCTION(_input[arrId].p);
    _output[arrId] = res;
}
float3 _translation_1;
float4 _rotation_1;

float _Power_1;
int _Iterations_1;
float _Bailout_1;

float _dist_1(float3 p) {
	float3 z = p;
	float dr = 1.0f;
	float r = 0.0f;
	for (int i = 0; i < _Iterations_1; i++)
	{
		r = length(z);
		if (r > _Bailout_1) break;

		// convert to polar coordinates
		float theta = acos(z.z / r);
		float phi = atan2(z.y, z.x);
		dr = pow(r, _Power_1 - 1.0) * _Power_1 * dr + 1.0f;

		// scale and rotate the point
		float zr = pow(r, _Power_1);
		theta = theta * _Power_1;
		phi = phi * _Power_1;

		// convert back to cartesian coordinates
		z = zr * float3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
		z += p;
	}
	return 0.5 * log(r) * r / dr;
}

float _dist_xform_1(float3 p) {
    return _dist_1(qrot(qinv(_rotation_1), p - _translation_1));
}
float3 _translation_2;
float4 _rotation_2;

float _Radius_1;
float _Height_1;

float _dist_2(float3 p) {
    return lerp(length(p.xz) - _Radius_1, length(float3(p.x, abs(p.y) - _Height_1, p.z)) - _Radius_1,
            step(_Height_1, abs(p.y)));
}

float _dist_xform_2(float3 p) {
    return _dist_2(qrot(qinv(_rotation_2), p - _translation_2));
}
float3 _translation_3;
float4 _rotation_3;

float _R_1;

float _dist_3(float3 p) {
    float a = _dist_xform_1(p);
    float b = _dist_xform_2(p);
    if (!isfinite(a)) return b;
    if (!isfinite(b)) return a;
    float e = max(_R_1 - abs(a-b), 0);
    return min(a, b) - 0.25*e*e/_R_1;
}

float _dist_xform_3(float3 p) {
    return _dist_3(qrot(qinv(_rotation_3), p - _translation_3));
}

